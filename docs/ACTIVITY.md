# Activity Sink & Queries

Phase 4 ships the first-class activity sink and query surfaces so go-admin/go-cms can render audit feeds, lifecycle breakdowns, and other widgets without duplicating storage concerns.

## Schema

Migration `000003_user_activity.sql` provisions the `user_activity` table with:

| Column      | Description                                      |
| ----------- | ------------------------------------------------ |
| `id`        | UUID primary key generated by the sink           |
| `user_id`   | Optional user referenced by the event            |
| `actor_id`  | UUID of the admin/process that triggered action  |
| `tenant_id` | Tenant scope (defaults to all-zero UUID)         |
| `org_id`    | Org scope (defaults to all-zero UUID)            |
| `verb`      | Namespaced verb (`user.lifecycle.transition`)    |
| `object_type` / `object_id` | Subject of the action            |
| `channel`   | Source (“lifecycle”, “roles”, “preferences”)     |
| `ip`        | Optional IP address                              |
| `data`      | JSON payload with arbitrary metadata             |
| `created_at`| Timestamp assigned by the sink                   |

Indexes exist for `(tenant_id, org_id, created_at)`, `(user_id, created_at)`, `(object_type, object_id)`, and `verb` so dashboard filters remain fast. Postgres deployers can add a GIN index on `data` if they need richer querying.

## Default Bun Repository

`activity.NewRepository` returns a struct that implements both `types.ActivitySink` and `types.ActivityRepository`.

```go
store, err := activity.NewRepository(activity.RepositoryConfig{
    DB:    bunDB,
    Clock: types.SystemClock{},
    IDGen: types.UUIDGenerator{},
})
if err != nil {
    log.Fatal(err)
}

svc := users.New(users.Config{
    ActivitySink:       store,
    ActivityRepository: store,
    // other dependencies...
})
```

- `Log(ctx, record)` persists entries and automatically fills `ID`/`OccurredAt` when omitted.
- `ListActivity(ctx, filter)` powers feed-style pagination with scope, verb, keyword, and time-range filters.
- `ActivityStats(ctx, filter)` aggregates counts per verb for widgets like `admin.widget.user_stats`.

Because the repository satisfies both interfaces, most hosts only need to construct it once and wire it into the service configuration.

## Queries

The `query` package now exposes:

- `ActivityFeed` → paginated feed DTOs (`types.ActivityPage`) suitable for recent activity panels.
- `ActivityStatsQuery` → grouped counts per verb (`types.ActivityStats`).

Example:

```go
feed, err := svc.Queries().ActivityFeed.Query(ctx, types.ActivityFilter{
    Scope:      types.ScopeFilter{TenantID: tenantID},
    Verbs:      []string{"user.lifecycle.transition"},
    Pagination: types.Pagination{Limit: 20},
})
stats, _ := svc.Queries().ActivityStats.Query(ctx, types.ActivityStatsFilter{
    Scope: types.ScopeFilter{TenantID: tenantID},
})
```

Filters accept optional `UserID`, `ActorID`, `Channel`, `Since`, `Until`, and keyword matching (`verb`, `object_type`, `object_id`).

## Hooks and Commands

- Commands (lifecycle, roles, invites, password reset) already log structured events via the injected sink. After persistence, they trigger `Hooks.AfterActivity`, allowing apps to push WebSocket notifications or replicate events elsewhere.
- `command.ActivityLog` provides a reusable command that other modules can invoke to log custom verbs while still benefiting from hooks and storage.

## Testing & Extensibility

- `activity/bun_repository_test.go` exercises the Bun repository against SQLite.
- `command` integration tests wire lifecycle commands → activity sink → queries to ensure data flows correctly.
- Hosts can swap the storage layer by implementing `types.ActivitySink` and `types.ActivityRepository` (e.g., streaming to Kafka or using an external analytics DB).

Keep DTOs tenant-aware and prefer `types.ActivityFilter`/`types.ActivityStatsFilter` when exposing new transport endpoints so multi-tenant scoping remains enforced.
